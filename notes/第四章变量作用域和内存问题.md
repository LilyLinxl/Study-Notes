# 1.基本类型和引用类型的值（变量包含的值）

+ 1.变量松散类型的本质:只在特定的事件用于保存特定值的一个名字
+ 2.什么是基本类型的值？简单的数据段
+ 3.什么是引用类型的值？由多个值构成的对象

## 1.1 动态的属性
+ 1.谁有动态的属性？
引用类型值，既可以添加属性和方法，又可以去改变和删除这个方法
+ 2.为什么是动态的?
如果对象不被销毁则属性一直存在

## 1.2 复制变量值
+ 1.基本类型值的复制
```javascript
var num1 = 5;
var num2 = num1;
```
复制一份num1的值放到num2的空间中
num1,num2互相独立，互不影响
就像机器里做出的相同的冰淇淋，一个被吃掉了，另一个依然存在
+ 2.引用类型值的复制
```javascript
var obj1 = new Object();
var obj2 = new obj1;
```
复制的是一个指针,指针指向存储在堆中的一个对象。
obj1，obj2引用同一个对象，会互相影响。
就像给同一个冰淇淋取的两个名字，icecream被吃了也就是冰淇淋被吃了，会相互影响

## 1.3 传递参数（说不太清）
所有函数的参数都是**按值传递**的。
（可以把函数中的参数当作局部变量）
```javascript
function setName(obj){
obj.name="tom";
}
var person = new Object();
setName(person);
alert(person.name);//tom
```
虽然变量是按值传递的，但是obj也会按引用来访问同一个对象，这并不能说明参数是按引用传递的
```javascript
function setName(obj){
obj.name="tom";
obj = new Object();
obj.name = "lisa";
}
var person = new Object();
setName(person);
alert(person.name);//tom
```
如果person是按引用传递的值，那么person就会被自动修改为指向其name属性值为“lisa”的新对象。
所以虽然函数内部修改了参数的值，但是原始的引用仍未改变。

实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即销毁。
## 1.4 检测类型
+ 1.typeof ：操作符确定基本类型的数据类型
+ 2.instanceof ：检测引用类型的值
# 2.执行环境及作用域
执行环境：定义了变量 和 函数有权访问的其他数据。执行环境决定了它们各自的行为。
每个执行环境都有一个与之关联的**变量对象**。
+ 1.window对象：在web浏览器中，全局执行环境被认为是window对象。
+ 2.执行环境的所有代码执行完毕后，该环境被销毁，其中的变量和函数定义也随之销毁。
+ 3.每个函数都有自己的执行环境。
+ 4.作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链。
+ 用途：保证变量和函数的有序访问，这些变量和函数有权访问执行环境。
+ 作用域链的等级：从前到后>当前环境中的变量对象->外部环境中的变量对象->外部环境的外部环境的变量对象->...->全局执行环境的变量对象
+ 访问规则：内部环境可以通过作用域链访问所有外部环境，反之不可以。
作用域：变量对象所在的执行环境
## 2.1 延长作用域链
+ try-catch中的catch
+ with语句
## 2.2 没有块级作用域

### 2.2.1 声明变量

var声明的变量会自动被添加到最接近的环境中。

### 2.2.2 查询标识符

从作用域链的前端一直找到全局环境，直到找到这个标识符(变量名)为止

# 3.垃圾收集

原理：找出那些不再继续使用的变量，然后释放它占用的内存。

## 3.1 标记清除

+ 1.当变量进入环境时，给这个变量标记为“进入环境”（不能被释放）
+ 2.当变量离开环境时，标记为“离开环境”
+ 3.垃圾回收器销毁带有“离开环境”的变量

## 3.2 引用计数

跟踪记录每个值被引用的次数，将一个引用类型值赋给一个变量时，值的引用次数+1，包含对这个值引用的变量取了另外一个值，这个值的引用次数-1.垃圾收集器下次运行时将次数为0的内存释放

## 3.3 性能问题

垃圾收集器是周期性运行的，所以时间间隔很重要

## 3.4 管理内存

+ 1.优化内存占用的最佳方式：为执行中的代码只保存必要的数据，一旦数据不再有用，最好通过将其值设置为null来释放它的引用即接触引用。（适用于大多数全局变量和全局对象的属性）
+ 2.接触引用的真正作用在于让值脱离执行环境，以便垃圾回收器下次运行时将其回收。

